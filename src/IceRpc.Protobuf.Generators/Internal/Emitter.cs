// Copyright (c) ZeroC, Inc.

namespace IceRpc.Protobuf.Generators.Internal;

internal class Emitter
{
    internal string Emit(IReadOnlyList<ServiceClass> serviceClasses, CancellationToken cancellationToken)
    {
        var generatedClasses = new List<string>();
        foreach (ServiceClass serviceClass in serviceClasses)
        {
            // stop if we're asked to.
            cancellationToken.ThrowIfCancellationRequested();

            string dispatchImplementation;
            if (serviceClass.ServiceMethods.Count > 0)
            {
                dispatchImplementation = "";
                foreach (ServiceMethod serviceMethod in serviceClass.ServiceMethods)
                {
                    dispatchImplementation += @$"
    ""{serviceMethod.OperationName}"" =>
        request.Dispatch{serviceMethod.MethodKind}Async(
            {serviceMethod.InputTypeName}.Parser,
            ({serviceMethod.InterfaceName})this,
            static (service, input, features, cancellationToken) =>
                service.{serviceMethod.MethodName}(input, features, cancellationToken),
            cancellationToken),".Trim();

                    dispatchImplementation += "\n\n";
                }

                if (serviceClass.HasBaseServiceClass)
                {
                    dispatchImplementation += @$"
_ => base.DispatchAsync(request, cancellationToken)".Trim();
                }
                else
                {
                    dispatchImplementation += @$"
_ => new(new IceRpc.OutgoingResponse(request, IceRpc.StatusCode.NotImplemented))".Trim();
                }

                dispatchImplementation = @$"
request.Operation switch
{{
    {dispatchImplementation.WithIndent("    ")}
}};".Trim();
            }
            else
            {
                dispatchImplementation = serviceClass.HasBaseServiceClass ?
                    "base.DispatchAsync(request, cancellationToken);" :
                    "new(new IceRpc.OutgoingResponse(request, IceRpc.StatusCode.NotImplemented));";
            }

            string methodModifier =
                serviceClass.HasBaseServiceClass ? "public override" :
                serviceClass.IsSealed ? "public" : "public virtual";

            string dispatcherClass = $@"
/// <summary>Implements <see cref=""IceRpc.IDispatcher"" /> for the Protobuf service(s) implemented by this class.
/// </summary>
partial {serviceClass.Keyword} {serviceClass.Name} : IceRpc.IDispatcher
{{
    /// <summary>Dispatches an incoming request to a method of {serviceClass.Name} based on the operation name carried
    /// by the request. With IceRPC + Protobuf, operation names are the same as Protobuf rpc method names.</summary>
    /// <param name=""request"">The incoming request.</param>
    /// <param name=""cancellationToken"">A cancellation token that receives the cancellation requests.</param>
    /// <returns>The outgoing response.</returns>
    /// <exception cref=""IceRpc.DispatchException"">Thrown if the rpc method name carried by the request does not
    /// correspond to any method implemented by this class. The exception status code is
    /// <see cref=""IceRpc.StatusCode.NotImplemented"" /> in this case.</exception>
    {methodModifier} global::System.Threading.Tasks.ValueTask<IceRpc.OutgoingResponse> DispatchAsync(
        IceRpc.IncomingRequest request,
        global::System.Threading.CancellationToken cancellationToken) =>
        {dispatchImplementation.WithIndent("        ")}
}}";

            string container = dispatcherClass;
            ContainerDefinition? containerDefinition = serviceClass;
            while (containerDefinition.Enclosing is ContainerDefinition parent)
            {
                container = GenerateContainer($"partial {parent.Keyword} {parent.Name}", container);
                containerDefinition = parent;
            }

            if (serviceClass.ContainingNamespace is not null)
            {
                container = GenerateContainer($"namespace {serviceClass.ContainingNamespace}", container);
            }
            generatedClasses.Add(container);
        }

        string generated = @$"
// <auto-generated/>
// IceRpc.Protobuf.Generators version: {typeof(ServiceGenerator).Assembly.GetName().Version!.ToString(3)}

#nullable enable

#pragma warning disable CS0612 // Type or member is obsolete
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS0619 // Type or member is obsolete

using IceRpc.Protobuf;

";
        generated += string.Join("\n\n", generatedClasses).Trim();
        generated += "\n";
        return generated.ReplaceLineEndings();
    }

    private static string GenerateContainer(string header, string body)
    {
        return $@"
{header}
{{
    {body.WithIndent("    ")}
}}".Trim();
    }
}
