// Copyright (c) ZeroC, Inc. All rights reserved.

using IceRpc.Internal;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;

namespace IceRpc
{
    /// <summary>A proxy is a local ambassador for a remote IceRPC service, and can send requests to this remote
    /// service. It can also be encoded in requests and responses. There are two forms of proxies: untyped proxies
    /// (instances of this class), and typed proxies that are Prx structs generated by the Slice compiler. Each typed
    /// proxy struct holds only a Proxy.</summary>
    /// <seealso cref="Slice.IPrx"/>
    public sealed class Proxy : IEquatable<Proxy>
    {
        /// <summary>The default invoker of proxies.</summary>
        public static IInvoker DefaultInvoker { get; } =
            new InlineInvoker((request, cancel) =>
                request.Connection?.InvokeAsync(request, cancel) ??
                    throw new ArgumentNullException(nameof(request), $"{nameof(request.Connection)} is null"));

        /// <summary>Gets or sets the secondary endpoints of this proxy.</summary>
        /// <value>The secondary endpoints of this proxy.</value>
        public ImmutableList<Endpoint> AltEndpoints
        {
            get => _altEndpoints;

            set
            {
                if (value.Count > 0)
                {
                    if (_endpoint == null)
                    {
                        throw new ArgumentException(
                            $"cannot set {nameof(AltEndpoints)} when {nameof(Endpoint)} is empty",
                            nameof(AltEndpoints));
                    }

                    if (value.Any((Func<Endpoint, bool>)(e => (bool)(e.Protocol != Protocol))))
                    {
                        throw new ArgumentException($"the protocol of all endpoints must be {Protocol}",
                                                    nameof(AltEndpoints));
                    }
                }
                // else, no need to check anything, an empty list is always fine.

                _altEndpoints = value;
            }
        }

        /// <summary>Gets or sets the connection of this proxy. Setting the connection does not affect the proxy
        /// endpoints (if any); in particular, set does check the new connection is compatible with these endpoints.
        /// </summary>
        /// <value>The connection for this proxy, or null if the proxy does not have a connection.</value>
        public Connection? Connection
        {
            get => _connection;
            set => _connection = value;
        }

        /// <summary>The encoding that a caller should use when encoding request parameters when such a caller supports
        /// multiple encodings. Its value is usually the encoding of the protocol.</summary>
        public Encoding Encoding { get; set; }

        /// <summary>Gets or sets the main endpoint of this proxy.</summary>
        /// <value>The main endpoint of this proxy, or null if this proxy has no endpoint.</value>
        public Endpoint? Endpoint
        {
            get => _endpoint;

            set
            {
                if (value != null)
                {
                    if (value.Protocol != Protocol)
                    {
                        throw new ArgumentException(
                            "the new endpoint must use the proxy's protocol",
                            nameof(Endpoint));
                    }
                    if (_params.Count > 0)
                    {
                        throw new ArgumentException(
                            "cannot set endpoint on a proxy with parameters",
                            nameof(Endpoint));
                    }
                }
                else if (_altEndpoints.Count > 0)
                {
                    throw new ArgumentException(
                        $"cannot clear {nameof(Endpoint)} when {nameof(AltEndpoints)} is not empty",
                        nameof(Endpoint));
                }
                _endpoint = value;
            }
        }

        /// <summary>Gets or sets the fragment.</summary>
        public string Fragment
        {
            get => _fragment;
            set
            {
                if (!IsValid(value, "\"<>\\^`{|}"))
                {
                    throw new ArgumentException(
                        @$"invalid fragment '{value
                        }'; a valid fragment contains only unreserved characters, reserved characters or '%'",
                        nameof(Fragment));
                }

                _fragment = value;
            }
        }

        /// <summary>Gets or sets the invoker of this proxy.</summary>
        public IInvoker Invoker { get; set; } = DefaultInvoker;

        /// <summary>Gets the path of this proxy. This path is a percent-escaped URI path.</summary>
        // private set only used in WithPath
        public string Path { get; private set; }

        /// <summary>The parameters of this proxy. Always empty when this <see cref="Endpoint"/> is not null.</summary>
        public ImmutableDictionary<string, string> Params
        {
            get => _params;
            set
            {
                if (_endpoint != null && value.Count > 0)
                {
                    throw new ArgumentException("cannot set parameters on a proxy with an endpoint", nameof(Params));
                }
                _params = value;
            }
        }

        /// <summary>The protocol of this proxy.</summary>
        public Protocol Protocol { get; }

        private ImmutableList<Endpoint> _altEndpoints = ImmutableList<Endpoint>.Empty;
        private volatile Connection? _connection;
        private Endpoint? _endpoint;
        private string _fragment = "";

        private ImmutableDictionary<string, string> _params = ImmutableDictionary<string, string>.Empty;

        /// <summary>The equality operator == returns true if its operands are equal, false otherwise.</summary>
        /// <param name="lhs">The left hand side operand.</param>
        /// <param name="rhs">The right hand side operand.</param>
        /// <returns><c>true</c> if the operands are equal, otherwise <c>false</c>.</returns>
        public static bool operator ==(Proxy? lhs, Proxy? rhs)
        {
            if (ReferenceEquals(lhs, rhs))
            {
                return true;
            }

            if (lhs is null || rhs is null)
            {
                return false;
            }
            return lhs.Equals(rhs);
        }

        /// <summary>The inequality operator != returns true if its operands are not equal, false otherwise.</summary>
        /// <param name="lhs">The left hand side operand.</param>
        /// <param name="rhs">The right hand side operand.</param>
        /// <returns><c>true</c> if the operands are not equal, otherwise <c>false</c>.</returns>
        public static bool operator !=(Proxy? lhs, Proxy? rhs) => !(lhs == rhs);

        /// <summary>Creates a proxy from a connection and a path.</summary>
        /// <param name="connection">The connection of the new proxy. If it's a client connection, the endpoint of the
        /// new proxy is <see cref="Connection.RemoteEndpoint"/>; otherwise, the new proxy has no endpoint.</param>
        /// <param name="path">The path of the proxy.</param>
        /// <param name="invoker">The invoker of the new proxy.</param>
        /// <returns>The new proxy.</returns>
        public static Proxy FromConnection(Connection connection, string path, IInvoker? invoker = null)
        {
            var proxy = new Proxy(path, connection.Protocol);
            proxy.Endpoint = connection.IsServer ? null : connection.RemoteEndpoint;
            proxy.Connection = connection;
            proxy.Invoker = invoker ?? DefaultInvoker;
            return proxy;
        }

        /// <summary>Creates a proxy from a path and protocol.</summary>
        /// <param name="path">The path.</param>
        /// <param name="protocol">The protocol.</param>
        /// <returns>The new proxy.</returns>
        public static Proxy FromPath(string path, Protocol? protocol = null) => new(path, protocol ?? Protocol.IceRpc);

        /// <summary>Creates a proxy from a string and an invoker.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="invoker">The invoker of the new proxy.</param>
        /// <param name="format">The proxy format to use for parsing. <c>null</c> is equivalent to
        /// <see cref="UriProxyFormat.Instance"/>.</param>
        /// <returns>The parsed proxy.</returns>
        public static Proxy Parse(string s, IInvoker? invoker = null, IProxyFormat? format = null) =>
            (format ?? UriProxyFormat.Instance).Parse(s, invoker);

        /// <summary>Tries to create a proxy from a string and invoker.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="invoker">The invoker. <c>null</c> is equivalent to <see cref="DefaultInvoker"/>.</param>
        /// <param name="format">The proxy format to use for parsing. <c>null</c> is equivalent to
        /// <see cref="UriProxyFormat.Instance"/>.</param>
        /// <param name="proxy">The parsed proxy.</param>
        /// <returns><c>true</c> when the string is parsed successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
            string s,
            IInvoker? invoker,
            IProxyFormat? format,
            [NotNullWhen(true)] out Proxy? proxy) =>
            (format ?? UriProxyFormat.Instance).TryParse(s, invoker, out proxy);

        /// <summary>Creates a shallow copy of this proxy. It's a safe copy since the only container property
        /// (AltEndpoints) is immutable.</summary>
        /// <returns>A copy of this proxy.</returns>
        public Proxy Clone() => (Proxy)MemberwiseClone();

        /// <inheritdoc/>
        public bool Equals(Proxy? other)
        {
            if (other == null)
            {
                return false;
            }
            else if (ReferenceEquals(this, other))
            {
                return true;
            }

            if (Encoding != other.Encoding)
            {
                return false;
            }
            if (_endpoint != other._endpoint)
            {
                return false;
            }

            // Only compare the connections of endpointless proxies.
            if (_endpoint == null && _connection != other._connection)
            {
                return false;
            }
            if (!_altEndpoints.SequenceEqual(other._altEndpoints))
            {
                return false;
            }
            if (Invoker != other.Invoker)
            {
                return false;
            }
            if (Path != other.Path)
            {
                return false;
            }
            if (_fragment != other._fragment)
            {
                return false;
            }
            if (Protocol != other.Protocol)
            {
                return false;
            }
            if (!Params.DictionaryEqual(other.Params))
            {
                return false;
            }

            return true;
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj) => Equals(obj as Proxy);

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            // We only hash a subset of the properties to keep GetHashCode reasonably fast.
            var hash = new HashCode();
            hash.Add(Invoker);
            hash.Add(Path);
            hash.Add(Protocol);
            if (_endpoint != null)
            {
                hash.Add(_endpoint.GetHashCode());
            }
            else if (_connection != null)
            {
                hash.Add(_connection);
            }
            return hash.ToHashCode();
        }

        /// <summary>Converts this proxy into a string using the default URI format.</summary>
        public override string ToString() => ToString(UriProxyFormat.Instance);

        /// <summary>Converts this proxy into a string using a specific format.</summary>
        public string ToString(IProxyFormat format) => format.ToString(this);

        /// <summary>Creates a copy of this proxy with a new path.</summary>
        /// <param name="path">The new path.</param>
        /// <returns>A new proxy with the specified path.</returns>
        public Proxy WithPath(string path)
        {
            Proxy proxy = Clone();
            proxy.Path = path;

            if (Protocol == Protocol.Ice && proxy.Endpoint == null)
            {
                // clear cached connection of well-known proxy
                proxy.Connection = null;
            }
            return proxy;
        }

        /// <summary>Makes sure path is valid.</summary>
        /// <exception name="ArgumentException">Thrown if <paramref name="path"/> is not valid.</exception>
        internal static void CheckPath(string path, string paramName)
        {
            if (!IsValidPath(path))
            {
                throw new ArgumentException(
                    @$"invalid path '{path
                    }'; a valid path starts with '/' and contains only unreserved characters, '%' or reserved characters other than '?' and '#'",
                    paramName);
            }
        }

        /// <summary>Checks if <paramref name="path"/> starts with <c>/</c> and contains only unreserved characters,
        /// <c>%</c>, or reserved characters other than <c>?</c> and <c>#</c>.</summary>
        /// <param name="path">The path to check.</param>
        /// <returns>True if <paramref name="path"/> is a valid path; otherwise, false.</returns>
        internal static bool IsValidPath(string path)
        {
            if (path.Length == 0 || path[0] != '/')
            {
                return false;
            }

            return IsValid(path, "\"<>#?\\^`{|}");
        }

        /// <summary>Constructs a new proxy.</summary>
        /// <param name="path">The proxy path.</param>
        /// <param name="protocol">The proxy protocol.</param>
        internal Proxy(string path, Protocol protocol)
        {
            Protocol = protocol;
            CheckPath(path, nameof(path));
            Path = path;
            Encoding = protocol.SliceEncoding ?? Encoding.Unknown;
        }

        private static bool IsValid(string s, string invalidChars)
        {
            // The printable ASCII character range is x20 (space) to x7E inclusive. Space is an invalid character in
            // addition to the invalid characters in the invalidChars string.
            foreach (char c in s)
            {
                if (c.CompareTo('\x20') <= 0 ||
                    c.CompareTo('\x7F') >= 0 ||
                    invalidChars.Contains(c, StringComparison.InvariantCulture))
                {
                    return false;
                }
            }
            return true;
        }
    }
}
