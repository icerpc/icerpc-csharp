// Copyright (c) ZeroC, Inc.

using ZeroC.CodeBuilder;

namespace IceRpc.Protobuf.Generators.Internal;

internal class Emitter
{
    internal string Emit(ServiceClass serviceClass, CancellationToken cancellationToken)
    {
        // Stop if we're asked to.
        cancellationToken.ThrowIfCancellationRequested();

        CodeBlock codeBlock = Preamble();

        if (serviceClass.ContainingNamespace is not null)
        {
            codeBlock.AddBlock($"namespace {serviceClass.ContainingNamespace};");
        }

        // We need to implement IDispatcher all the time, even when there is a base class that itself implements
        // IDispatcher.
        CodeBlock container = new ContainerBuilder($"partial {serviceClass.Keyword}", serviceClass.Name)
            .AddBase("IceRpc.IDispatcher")
            .AddComment(
                "summary",
                @"Implements <see cref=""IceRpc.IDispatcher"" /> for the Protobuf service(s) implemented by this class")
            .AddBlock(GenerateDispatch(serviceClass))
            .Build();

        ContainerDefinition? containerDefinition = serviceClass;
        while (containerDefinition.Enclosing is ContainerDefinition enclosing)
        {
            container = new ContainerBuilder($"partial {enclosing.Keyword}", enclosing.Name)
                .AddBlock(container)
                .Build();

            containerDefinition = enclosing;
        }

        codeBlock.AddBlock(container);
        return codeBlock.ToString().ReplaceLineEndings();
    }

    private static CodeBlock GenerateDispatch(ServiceClass serviceClass)
    {
        string methodModifier = serviceClass.HasBaseServiceClass
            ? "public override"
            : serviceClass.IsSealed ? "public" : "public virtual";

        return @$"
/// <summary>Dispatches an incoming request to a method of <see cref=""{serviceClass.Name}"" /> based on
/// the operation name carried by the request. With IceRPC + Protobuf, operation names are the same as
/// Protobuf rpc method names.</summary>
/// <param name=""request"">The incoming request.</param>
/// <param name=""cancellationToken"">A cancellation token that receives the cancellation requests.</param>
/// <returns>The outgoing response.</returns>
{methodModifier} global::System.Threading.Tasks.ValueTask<IceRpc.OutgoingResponse> DispatchAsync(
    IceRpc.IncomingRequest request,
    global::System.Threading.CancellationToken cancellationToken) =>
        {GenerateDispatchBody(serviceClass).Indent().Indent()};";
    }

    private static CodeBlock GenerateDispatchBody(ServiceClass serviceClass)
    {
        if (serviceClass.ServiceMethods.Count > 0)
        {
            var arms = new CodeBlock();

            foreach (ServiceMethod serviceMethod in serviceClass.ServiceMethods)
            {
                arms.AddBlock(GenerateDispatchSwitchArm(serviceMethod));
            }
            arms = arms.Indent(); // This indents all the arms in the switch.

            var fallback = new CodeBlock(
                serviceClass.HasBaseServiceClass ?
                    "_ => base.DispatchAsync(request, cancellationToken)" :
                    "_ => new(new IceRpc.OutgoingResponse(request, IceRpc.StatusCode.NotImplemented))").Indent();

            return @$"request.Operation switch
{{
    {arms}

    {fallback}
}}";
        }
        else
        {
            return serviceClass.HasBaseServiceClass ?
                "base.DispatchAsync(request, cancellationToken)" :
                "new(new IceRpc.OutgoingResponse(request, IceRpc.StatusCode.NotImplemented))";
        }
    }

    private static CodeBlock GenerateDispatchSwitchArm(ServiceMethod serviceMethod) =>
        @$"""{serviceMethod.OperationName}"" =>
    request.Dispatch{serviceMethod.MethodKind}Async(
        {serviceMethod.InputTypeName}.Parser,
        ({serviceMethod.InterfaceName})this,
        static (service, input, features, cancellationToken) =>
            service.{serviceMethod.MethodName}(input, features, cancellationToken),
        cancellationToken),";

    private static CodeBlock Preamble() => @$"
// <auto-generated/>
// IceRpc.Protobuf.Generators version: {typeof(ServiceGenerator).Assembly.GetName().Version!.ToString(3)}

#nullable enable

#pragma warning disable CS0612 // Type or member is obsolete
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS0619 // Type or member is obsolete

using IceRpc.Protobuf;
";
}
