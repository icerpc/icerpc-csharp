<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

    <PropertyGroup>
        <TimeStampServer>http://timestamp.digicert.com</TimeStampServer>
        <SignCommandSHA1>/f "$(SIGN_CERTIFICATE)" /p $(SIGN_PASSWORD) /tr $(TimeStampServer)</SignCommandSHA1>
        <SignCommandSHA256>/f "$(SIGN_CERTIFICATE)" /p $(SIGN_PASSWORD) /tr $(TimeStampServer) /td sha256 /fd sha256 /as</SignCommandSHA256>
    </PropertyGroup>

    <!-- Authenticode sign task that retries on failures -->
    <UsingTask TaskName="SignTask"
                TaskFactory="CodeTaskFactory"
                AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll">
        <ParameterGroup>
            <WorkingDirectory ParameterType="System.String" Required="true"/>
            <AdditionalOptions ParameterType="System.String" Required="true"/>
            <Files ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="True"/>
        </ParameterGroup>
        <Task>
            <Code Type="Class" Language="cs" Source="$(MSBuildThisFileDirectory)/SignTask.cs" />
        </Task>
    </UsingTask>

    <PropertyGroup Condition="'$(PUBLIC_KEYFILE)' != '' Or '$(KEYFILE)' != ''">
        <SignAssembly>true</SignAssembly>
        <!-- If PUBLIC_KEYFILE is set we use delay sign to sign the assembly -->
        <DelaySign>true</DelaySign>
        <AssemblyOriginatorKeyFile Condition="'$(PUBLIC_KEYFILE)' != ''">$(PUBLIC_KEYFILE)</AssemblyOriginatorKeyFile>

        <!-- If PUBLIC_KEYFILE is not set sign the assembly using KEYFILE -->
        <DelaySign Condition="'$(PUBLIC_KEYFILE)' == ''">false</DelaySign>
        <AssemblyOriginatorKeyFile Condition="'$(PUBLIC_KEYFILE)' == ''">$(KEYFILE)</AssemblyOriginatorKeyFile>
    </PropertyGroup>

  <Target Name="SignPackage"
          BeforeTargets="CopyFilesToOutputDirectory"
          Condition="'$(OS)' == 'Windows_NT' and Exists('$(SIGN_CERTIFICATE)') and (!Exists('$(IntermediateOutputPath)sign.log') or $([System.IO.File]::GetLastWriteTime('$(IntermediateOutputPath)$(TargetName)$(TargetExt)').Ticks) &gt; $([System.IO.File]::GetLastWriteTime('$(IntermediateOutputPath)sign.log').Ticks))">
    <Message Text="Signing $(IntermediateOutputPath)$(TargetName)$(TargetExt)" />

    <!-- If both KEYFILE and PUBLIC_KEYFILE are set we re-sign the assembly using KEYFILE after it has been build -->
    <Exec Command="sn -Ra &quot;$(IntermediateOutputPath)$(TargetName)$(TargetExt)&quot; &quot;$(KEYFILE)&quot;"
          Condition="'$(KEYFILE)' != '' and '$(PUBLIC_KEYFILE)' != ''" />

    <!-- Authenticode signing -->
    <SignTask
        WorkingDirectory="$(IntermediateOutputPath)"
        AdditionalOptions="$(SignCommandSHA1)"
        Files="$(TargetName)$(TargetExt)"/>

    <SignTask
        WorkingDirectory="$(IntermediateOutputPath)"
        AdditionalOptions="$(SignCommandSHA256)"
        Files="$(TargetName)$(TargetExt)"/>

    <WriteLinesToFile File                = "$(IntermediateOutputPath)sign.log"
                      Encoding            = "Unicode"
                      Overwrite           = "true"
                      Lines               = "Signing $(IntermediateOutputPath)$(TargetName)$(TargetExt)"/>
  </Target>

  <Target Name="SignPackageClean" AfterTargets="Clean" Condition="'$(OS)' == 'Windows_NT' ">
     <Delete Files="$(IntermediateOutputPath)sign.log" />
  </Target>

  <PropertyGroup>
      <BuildDependsOn>
          $(BuildDependsOn);
          SignPackage
      </BuildDependsOn>
  </PropertyGroup>
</Project>
