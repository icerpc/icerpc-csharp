// Copyright (c) ZeroC, Inc. All rights reserved.

using IceRpc.Slice.Internal;
using NUnit.Framework;

namespace IceRpc.Slice.Tests;

/// <summary>Test decoding strings with the supported Slice encodings.</summary>
[Parallelizable(scope: ParallelScope.All)]
public class DecodeStringTests
{
    /// <summary>Tests the decoding of a string. The only difference between decoding strings with the 1.1 encoding and
    /// the 2.0 encoding is how the size gets encoded. Since <see cref="Decoding_size(string, byte[], byte[])"/>
    /// tests the size encoding, this test only needs to verify how strings are decoded with 2.0. </summary>
    /// <param name="testString">The string to be decoded.</param>
    [TestCase("")]
    [TestCase("Lorem ipsum dolor sit amet, no explicari repudiare vis, an dicant legimus ponderum sit.")]
    [TestCase("êµ­ë¯¼ê²½ì œì˜ ë°œì „ì„ ìœ„í•œ ì¤‘ìš”ì •ì±…ì˜ ìˆ˜ë¦½ì— ê´€í•˜ì—¬ ëŒ€í†µë ¹ì˜ ìë¬¸ì— ì‘í•˜ê¸° ìœ„í•˜ì—¬ êµ­ë¯¼ê²½ì œìë¬¸íšŒì˜ë¥¼ ë‘˜ ìˆ˜ ìˆë‹¤")] // Korean
    [TestCase("æ—…ãƒ­äº¬é’åˆ©ã‚»ãƒ ãƒ¬å¼±æ”¹ãƒ•ãƒ¨ã‚¹æ³¢åºœã‹ã°ã¼æ„é€ã§ã¼èª¿æ²å¯ŸãŸã‚¹æ—¥è¥¿é‡ã‚±ã‚¢ãƒŠä½æ©‹ãƒ¦ãƒ ãƒŸã‚¯é †å¾…ãµã‹ã‚“ã¼äººå¥¨è²¯é¡ã™ã³ã")]  // Japanese
    [TestCase("ğŸ˜ğŸ˜‚ğŸ˜ƒğŸ˜„ğŸ˜…ğŸ˜†ğŸ˜‰ğŸ˜ŠğŸ˜‹ğŸ˜ŒğŸ˜ğŸ˜ğŸ˜’ğŸ˜“ğŸ˜”ğŸ˜–")]
    public void Decode_string(string testString)
    {
        var buffer = new byte[256];
        var bufferWriter = new MemoryBufferWriter(buffer);
        var encoder = new SliceEncoder(bufferWriter, Encoding.Slice20);
        encoder.EncodeString(testString);
        byte[] encodedString = buffer[0..bufferWriter.WrittenMemory.Length];
        var sut = new SliceDecoder(encodedString, Encoding.Slice20);

        var r1 = sut.DecodeString();

        Assert.That(r1, Is.EqualTo(testString));
        Assert.That(sut.Consumed, Is.EqualTo(encodedString.Length));
    }
}
