// Copyright (c) ZeroC, Inc. All rights reserved.

using IceRpc.Internal;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace IceRpc
{
    /// <summary>A proxy is a local ambassador for a remote IceRPC service and is used to create
    /// <see cref="OutgoingRequest"/> to this remote service. This Proxy class can be used with any encoding. The Slice
    /// proxies generated by the Slice compiler are typed structures (Prx structs) that wrap this Proxy: each Prx struct
    /// holds only a Proxy.</summary>
    /// <seealso cref="Slice.IPrx"/>
    public sealed record class Proxy
    {
        /// <summary>The default invoker of proxies.</summary>
        public static IInvoker DefaultInvoker { get; } =
            new InlineInvoker((request, cancel) =>
                request.Connection?.InvokeAsync(request, cancel) ??
                    throw new ArgumentNullException(nameof(request), $"{nameof(request.Connection)} is null"));

        /// <summary>Gets or sets the secondary endpoints of this proxy.</summary>
        /// <value>The secondary endpoints of this proxy.</value>
        public ImmutableList<Endpoint> AltEndpoints
        {
            get => _altEndpoints;

            set
            {
                CheckSupportedProtocol(nameof(AltEndpoints));

                if (value.Count > 0)
                {
                    if (_endpoint == null)
                    {
                        throw new InvalidOperationException(
                            $"cannot set {nameof(AltEndpoints)} when {nameof(Endpoint)} is empty");
                    }

                    if (value.Any((Func<Endpoint, bool>)(e => (bool)(e.Protocol != Protocol))))
                    {
                        throw new ArgumentException(
                            $"the protocol of all alt endpoints must be {Protocol}",
                            nameof(AltEndpoints));
                    }
                }
                // else, no need to check anything, an empty list is always fine.

                _altEndpoints = value;
                OriginalUri = null;
            }
        }

        /// <summary>Gets or sets the connection of this proxy. Setting the connection does not affect the proxy
        /// endpoints (if any).</summary>
        /// <value>The connection for this proxy, or null if the proxy does not have a connection.</value>
        public Connection? Connection
        {
            get => _connection;

            set
            {
                CheckSupportedProtocol(nameof(Connection));
                if (value?.Protocol is Protocol newProtocol && newProtocol != Protocol)
                {
                    throw new ArgumentException("cannot change the protocol of a proxy", nameof(Connection));
                }
                _connection = value;
            }
        }

        /// <summary>The encoding that a caller should use when encoding request parameters when such a caller supports
        /// multiple encodings. Its value is usually the encoding of the protocol.</summary>
        // TODO: remove
        // Note: if we kept it, it should use an _encoding field and clear OriginalUri in set
        public Encoding Encoding { get; set; } = Encoding.Unknown;

        /// <summary>Gets or sets the main endpoint of this proxy.</summary>
        /// <value>The main endpoint of this proxy, or null if this proxy has no endpoint.</value>
        public Endpoint? Endpoint
        {
            get => _endpoint;

            set
            {
                CheckSupportedProtocol(nameof(Endpoint));
                if (value?.Protocol is Protocol newProtocol && newProtocol != Protocol)
                {
                    throw new ArgumentException("cannot change the protocol of a proxy", nameof(Endpoint));
                }

                if (value != null)
                {
                    if (_params.Count > 0)
                    {
                        throw new InvalidOperationException(
                            $"cannot set {nameof(Endpoint)} on a proxy with parameters");
                    }
                }
                else if (_altEndpoints.Count > 0)
                {
                    throw new InvalidOperationException(
                        $"cannot clear {nameof(Endpoint)} when {nameof(AltEndpoints)} is not empty");
                }
                _endpoint = value;
                OriginalUri = null;
            }
        }

        /// <summary>Gets or initializes the fragment.</summary>
        public string Fragment
        {
            get => _fragment;
            init
            {
                if (Protocol.HasFragment)
                {
                    if (!IsValidFragment(value))
                    {
                        throw new FormatException(
                            @$"invalid fragment '{value
                            }'; a valid fragment contains only unreserved characters, reserved characters or '%'");
                    }

                    _fragment = value;
                    OriginalUri = null;
                }
                else if (value.Length > 0 || !Protocol.IsSupported)
                {
                    throw new InvalidOperationException($"cannot set {nameof(Fragment)} on a '{Protocol}' proxy");
                }
                // else we ignore initializing an empty fragment on a proxy with a supported protocol that does not
                // support fragments
            }
        }

        /// <summary>Gets or sets the invoker of this proxy.</summary>
        public IInvoker Invoker
        {
            get => _invoker;
            set
            {
                CheckSupportedProtocol(nameof(Invoker));
                _invoker = value;
            }
        }

        /// <summary>Returns the URI used to create this proxy, if this proxy was created from a URI and URI-derived
        /// properties such as <see cref="Endpoint"/> have not been updated.</summary>
        public Uri? OriginalUri { get; private set; }

        /// <summary>Gets or initializes the path of this proxy.</summary>
        public string Path
        {
            get => _path;
            init
            {
                if (Protocol == Protocol.Relative || Protocol.IsSupported)
                {
                    CheckPath(value);
                    _path = value;
                    OriginalUri = null;
                }
                else
                {
                    throw new InvalidOperationException($"cannot set {nameof(Path)} on a '{Protocol}' proxy");
                }
            }
        }

        /// <summary>The parameters of this proxy. Always empty when <see cref="Endpoint"/> is not null.</summary>
        public ImmutableDictionary<string, string> Params
        {
            get => _params;
            set
            {
                CheckSupportedProtocol(nameof(Params));
                CheckParams(value, nameof(Params));

                if (_endpoint != null && value.Count > 0)
                {
                    throw new InvalidOperationException($"cannot set {nameof(Params)} on a proxy with an endpoint");
                }

                _params = value;
                OriginalUri = null;
            }
        }

        /// <summary>The protocol of this proxy.</summary>
        public Protocol Protocol { get; }

        private ImmutableList<Endpoint> _altEndpoints = ImmutableList<Endpoint>.Empty;
        private volatile Connection? _connection;
        private Endpoint? _endpoint;
        private string _fragment = "";
        private IInvoker _invoker = DefaultInvoker;
        private ImmutableDictionary<string, string> _params = ImmutableDictionary<string, string>.Empty;
        private string _path = "/";

        /// <summary>Creates a proxy from a connection and a path.</summary>
        /// <param name="connection">The connection of the new proxy. If it's a client connection, the endpoint of the
        /// new proxy is <see cref="Connection.RemoteEndpoint"/>; otherwise, the new proxy has no endpoint.</param>
        /// <param name="path">The path of the proxy.</param>
        /// <param name="invoker">The invoker of the new proxy.</param>
        /// <returns>The new proxy.</returns>
        public static Proxy FromConnection(Connection connection, string path, IInvoker? invoker = null) =>
            new(connection.Protocol)
            {
                Path = path,
                Endpoint = connection.IsServer ? null : connection.RemoteEndpoint,
                Connection = connection,
                Invoker = invoker ?? DefaultInvoker
            };

        /// <summary>Creates a relative proxy.</summary>
        /// <param name="path">The path.</param>
        /// <returns>The new relative proxy.</returns>
        public static Proxy FromPath(string path) => new(Protocol.Relative) { Path = path };

        /// <summary>Checks if <paramref name="fragment"/> contains only unreserved characters, reserved characters, or
        /// <c>%</c>.</summary>
        /// <param name="fragment">The fragment to check.</param>
        /// <returns><c>true</c> if <paramref name="fragment"/> is a valid fragment; otherwise, <c>false</c>.</returns>
        public static bool IsValidFragment(string fragment) => IsValid(fragment, "\"<>\\^`{|}");

        /// <summary>Checks if <paramref name="name"/> is not empty and contains only lowercase ASCII letters, digits
        /// or <c>-</c>.</summary>
        /// <param name="name">The name to check.</param>
        /// <returns><c>true</c> if <paramref name="name"/> is a valid parameter name; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsValidParamName(string name)
        {
            if (name.Length == 0 || name == "alt-endpoint")
            {
                return false;
            }

            foreach (char c in name)
            {
                if (!(c.CompareTo('0') >= 0 && c.CompareTo('9') <= 0) &&
                    !(c.CompareTo('a') >= 0 && c.CompareTo('z') <= 0) &&
                    c != '-')
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>Checks if <paramref name="value"/> contains only unreserved characters, <c>%</c>, or reserved
        /// characters other than <c>#</c> and <c>&#38;</c>.</summary>
        /// <param name="value">The value to check.</param>
        /// <returns><c>true</c> if <paramref name="value"/> is a valid parameter value; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsValidParamValue(string value) => IsValid(value, "\"<>#&\\^`{|}");

        /// <summary>Checks if <paramref name="path"/> starts with <c>/</c> and contains only unreserved characters,
        /// <c>%</c>, or reserved characters other than <c>?</c> and <c>#</c>.</summary>
        /// <param name="path">The path to check.</param>
        /// <returns><c>true</c> if <paramref name="path"/> is a valid path; otherwise, <c>false</c>.</returns>
        public static bool IsValidPath(string path)
        {
            if (path.Length == 0 || path[0] != '/')
            {
                return false;
            }

            return IsValid(path, "\"<>#?\\^`{|}");
        }

        /// <summary>Creates a proxy from a string and an invoker.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="invoker">The invoker of the new proxy.</param>
        /// <param name="format">The proxy format to use for parsing. <c>null</c> is equivalent to
        /// <see cref="UriProxyFormat.Instance"/>.</param>
        /// <returns>The parsed proxy.</returns>
        public static Proxy Parse(string s, IInvoker? invoker = null, IProxyFormat? format = null) =>
            (format ?? UriProxyFormat.Instance).Parse(s, invoker);

        /// <summary>Tries to create a proxy from a string and invoker.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="invoker">The invoker. <c>null</c> is equivalent to <see cref="DefaultInvoker"/>.</param>
        /// <param name="format">The proxy format to use for parsing. <c>null</c> is equivalent to
        /// <see cref="UriProxyFormat.Instance"/>.</param>
        /// <param name="proxy">The parsed proxy.</param>
        /// <returns><c>true</c> when the string is parsed successfully; otherwise, <c>false</c>.</returns>
        public static bool TryParse(
            string s,
            IInvoker? invoker,
            IProxyFormat? format,
            [NotNullWhen(true)] out Proxy? proxy) =>
            (format ?? UriProxyFormat.Instance).TryParse(s, invoker, out proxy);

        /// <summary>Constructs a proxy from a protocol.</summary>
        /// <param name="protocol">The protocol.</param>
        /// <exception cref="ArgumentException">Thrown when <paramref name="protocol"/> is not a supported protocol or
        /// <see cref="Protocol.Relative"/>.</exception>
        public Proxy(Protocol protocol)
        {
            if (protocol.IsSupported || protocol == Protocol.Relative)
            {
                Protocol = protocol;
                Encoding = Protocol.SliceEncoding ?? Encoding.Unknown;
            }
            else
            {
                throw new ArgumentException(
                    $"protocol must be {nameof(Protocol.Relative)} or a supported protocol",
                    nameof(protocol));
            }
        }

        /// <summary>Constructs a proxy from a URI.</summary>
        public Proxy(Uri uri)
        {
            if (uri.IsAbsoluteUri)
            {
                Protocol = Protocol.FromString(uri.Scheme);
                _path = uri.AbsolutePath;
                _fragment = uri.Fragment.Length > 0 ? uri.Fragment[1..] : ""; // remove leading #

                if (Protocol.IsSupported)
                {
                    if (!_path.StartsWith('/'))
                    {
                        throw new FormatException($"invalid path in proxy URI '{uri.OriginalString}'");
                    }

                    if (_fragment.Length > 0 && !Protocol.HasFragment)
                    {
                        throw new FormatException($"invalid fragment in proxy URI '{uri.OriginalString}'");
                    }

                    (ImmutableDictionary<string, string> queryParams, string? altEndpointValue) = uri.ParseQuery();

                    // temporary
                    Encoding = Protocol.SliceEncoding!; // default value
                    if (queryParams.TryGetValue("encoding", out string? encoding))
                    {
                        Encoding = Encoding.FromString(encoding);
                        queryParams = queryParams.Remove("encoding");
                    }

                    if (uri.Authority.Length > 0)
                    {
                        _endpoint = new Endpoint(uri, Protocol, queryParams);

                        if (altEndpointValue != null)
                        {
                            // Split and parse recursively each endpoint
                            foreach (string endpointStr in altEndpointValue.Split(','))
                            {
                                string altUriString = $"{uri.Scheme}://{endpointStr}";

                                // The separator for endpoint parameters in alt-endpoint is $, so we replace these '$'
                                // by '&' before sending the string to Endpoint.FromString which uses '&' as separator.
                                _altEndpoints = _altEndpoints.Add(Endpoint.FromString(altUriString.Replace('$', '&')));
                            }
                        }
                    }
                    else
                    {
                        if (altEndpointValue != null)
                        {
                            throw new FormatException($"invalid alt-endpoint parameter in URI '{uri.OriginalString}'");
                        }

                        Params = queryParams;
                    }
                }
                // else, not a supported protocol so nothing to do
            }
            else // relative proxy
            {
                Protocol = Protocol.Relative;
                _path = uri.ToString();
                CheckPath(_path);
            }

            OriginalUri = uri;
        }

        /// <inheritdoc/>
        public bool Equals(Proxy? other)
        {
            if (other == null)
            {
                return false;
            }
            else if (ReferenceEquals(this, other))
            {
                return true;
            }

            if (Protocol != other.Protocol)
            {
                return false;
            }

            if (Protocol == Protocol.Relative)
            {
                return Path == other.Path;
            }
            else if (!Protocol.IsSupported)
            {
                Debug.Assert(OriginalUri != null);
                Debug.Assert(other.OriginalUri != null);
                return OriginalUri == other.OriginalUri;
            }

            // else non-relative proxies with a supported protocol

            if (Encoding != other.Encoding)
            {
                return false;
            }

            if (Path != other.Path)
            {
                return false;
            }
            if (Fragment != other.Fragment)
            {
                return false;
            }

            if (_endpoint != other._endpoint)
            {
                return false;
            }

            if (Invoker != other.Invoker)
            {
                return false;
            }

            // Only compare the connections of endpointless proxies.
            if (_endpoint == null && _connection != other._connection)
            {
                return false;
            }
            if (!_altEndpoints.SequenceEqual(other._altEndpoints))
            {
                return false;
            }
            if (!Params.DictionaryEqual(other.Params))
            {
                return false;
            }

            return true;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            if (Protocol == Protocol.Relative)
            {
                return Path.GetHashCode(StringComparison.Ordinal);
            }
            else if (!Protocol.IsSupported)
            {
                Debug.Assert(OriginalUri != null);
                return OriginalUri.GetHashCode();
            }

            // else non-relative proxy with a supported protocol

            // We only hash a subset of the properties to keep GetHashCode reasonably fast.
            var hash = new HashCode();
            hash.Add(Protocol);
            hash.Add(Path);
            hash.Add(Fragment);
            hash.Add(Invoker);

            if (_endpoint != null)
            {
                hash.Add(_endpoint);
            }
            else if (_connection != null)
            {
                hash.Add(_connection);
            }
            return hash.ToHashCode();
        }

        /// <summary>Converts this proxy into a string using the default URI format.</summary>
        public override string ToString() => ToString(UriProxyFormat.Instance);

        /// <summary>Converts this proxy into a string using a specific format.</summary>
        public string ToString(IProxyFormat format) => format.ToString(this);

        /// <summary>Converts this proxy into a Uri.</summary>
        public Uri ToUri() =>
            OriginalUri ?? (Protocol == Protocol.Relative ?
                new Uri(Path, UriKind.Relative) : new Uri(ToString(), UriKind.Absolute));

        /// <summary>Makes sure path is valid.</summary>
        /// <exception cref="FormatException">Thrown if <paramref name="path"/> is not valid.</exception>
        internal static void CheckPath(string path)
        {
            if (!IsValidPath(path))
            {
                throw new FormatException(
                    @$"invalid path '{path
                    }'; a valid path starts with '/' and contains only unreserved characters, '%' or reserved characters other than '?' and '#'");
            }
        }

        internal static void CheckParams(ImmutableDictionary<string, string> @params, string paramName)
        {
            foreach ((string name, string value) in @params)
            {
                if (!IsValidParamName(name))
                {
                    throw new ArgumentException($"invalid parameter name '{name}'", paramName);
                }
                if (!IsValidParamValue(value))
                {
                    throw new ArgumentException($"invalid parameter value '{value}'", paramName);
                }
            }
        }

        private static bool IsValid(string s, string invalidChars)
        {
            // The printable ASCII character range is x20 (space) to x7E inclusive. Space is an invalid character in
            // addition to the invalid characters in the invalidChars string.
            foreach (char c in s)
            {
                if (c.CompareTo('\x20') <= 0 ||
                    c.CompareTo('\x7F') >= 0 ||
                    invalidChars.Contains(c, StringComparison.InvariantCulture))
                {
                    return false;
                }
            }
            return true;
        }

        private void CheckSupportedProtocol(string propertyName)
        {
            if (Protocol == Protocol.Relative)
            {
                throw new InvalidOperationException($"cannot set {propertyName} on a relative proxy");
            }
            else if (!Protocol.IsSupported)
            {
                throw new InvalidOperationException($"cannot set {propertyName} on a '{Protocol}' proxy");
            }
        }
    }
}
