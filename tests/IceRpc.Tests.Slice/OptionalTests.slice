// Copyright (c) ZeroC, Inc. All rights reserved.

module IceRpc::Tests::Slice
{
    compact struct OneOptional
    {
        a: int?,
    }

    compact struct MultiOptional
    {
        mByte: byte?,
        mBool: bool?,
        mShort: short?,
        mInt: int?,
        mLong: long?,
        mFloat: float?,
        mDouble: double?,
        mUShort: ushort?,
        mUInt: uint?,
        mULong: ulong?,
        mVarInt: varint?,
        mVarLong: varlong?,
        mVarUInt: varuint?,
        mVarULong: varulong?,
        mString: string?,

        mMyEnum: MyEnum?,
        mMyCompactStruct: MyCompactStruct?,
        mAnotherCompactStruct: AnotherCompactStruct?,

        mByteSeq: ByteSeq?,
        mStringSeq: StringSeq?,
        mShortSeq: ShortSeq?,
        mMyEnumSeq: MyEnumSeq?,
        mMyCompactStructSeq: MyCompactStructSeq?,
        mAnotherCompactStructSeq: AnotherCompactStructSeq?,

        mIntDict: IntDict?,
        mStringDict: StringDict?,
        mUShortSeq: UShortSeq?,
        mVarULongSeq: VarULongSeq?,
        mVarIntSeq: VarIntSeq?,

        mByteDict: ByteDict?,
        mMyCompactStructDict: MyCompactStructDict?,
        mAnotherCompactStructDict: AnotherCompactStructDict?,
    }

    interface OptionalOperations
    {
        pingPongOne(o: OneOptional?) -> OneOptional?;
        pingPongMulti(o: MultiOptional?) -> MultiOptional?;

        opByte(p1: byte?) -> (r1: byte?, r2: byte?);

        opBool(p1: bool?) -> (r1: bool?, r2: bool?);

        opShort(p1: short?) -> (r1: short?, r2: short?);

        opInt(p1: int?) -> (r1: int?, r2: int?);

        opLong(p1: long?) -> (r1: long?, r2: long?);

        opFloat(p1: float?) -> (r1: float?, r2: float?);

        opDouble(p1: double?) -> (r1: double?, r2: double?);

        opString(p1: string?) -> (r1: string?, r2: string?);

        opMyEnum(p1: MyEnum?) -> (r1: MyEnum?, r2: MyEnum?);

        opMyCompactStruct(p1: MyCompactStruct?) -> (r1: MyCompactStruct?, r2: MyCompactStruct?);

        opAnotherCompactStruct(p1: AnotherCompactStruct?) -> (r1: AnotherCompactStruct?, r2: AnotherCompactStruct?);

        opByteSeq(p1: ByteSeq?) -> (r1: ByteSeq?, r2: ByteSeq?);
        opByteList(p1: ByteList?) -> (r1: ByteList?, r2: ByteList?);

        opBoolSeq(p1: BoolSeq?) -> (r1: BoolSeq?, r2: BoolSeq?);
        opBoolList(p1: BoolList?) -> (r1: BoolList?, r2: BoolList?);

        opShortSeq(p1: ShortSeq?) -> (r1: ShortSeq?, r2: ShortSeq?);
        opShortList(p1: ShortList?) -> (r1: ShortList?, r2: ShortList?);

        opIntSeq(p1: IntSeq?) -> (r1: IntSeq?, r2: IntSeq?);
        opIntList(p1: IntList?) -> (r1: IntList?, r2: IntList?);

        opLongSeq(p1: LongSeq?) -> (r1: LongSeq?, r2: LongSeq?);
        opLongList(p1: LongList?) -> (r1: LongList?, r2: LongList?);

        opFloatSeq(p1: FloatSeq?) -> (r1: FloatSeq?, r2: FloatSeq?);
        opFloatList(p1: FloatList?) -> (r1: FloatList?, r2: FloatList?);

        opDoubleSeq(p1: DoubleSeq?) -> (r1: DoubleSeq?, r2: DoubleSeq?);
        opDoubleList(p1: DoubleList?) -> (r1: DoubleList?, r2: DoubleList?);

        opStringSeq(p1: StringSeq?) -> (r1: StringSeq?, r2: StringSeq?);
        opStringList(p1: StringList?) -> (r1: StringList?, r2: StringList?);

        opMyCompactStructSeq(p1: MyCompactStructSeq?) -> (r1: MyCompactStructSeq?, r2: MyCompactStructSeq?);
        opMyCompactStructList(p1: MyCompactStructList?) -> (r1: MyCompactStructList?, r2: MyCompactStructList?);

        opAnotherCompactStructSeq(p1: AnotherCompactStructSeq?) -> (
            r1: AnotherCompactStructSeq?,
            r2: AnotherCompactStructSeq?,
        );
        opAnotherCompactStructList(p1: AnotherCompactStructList?) -> (
            r1: AnotherCompactStructList?,
            r2: AnotherCompactStructList?,
        );

        opIntDict(p1: IntDict?) -> (r1: IntDict?, r2: IntDict?);
        opStringDict(p1: StringDict?) -> (r1: StringDict?, r2: StringDict?);

        [cs:encoded-result] opMyCompactStructMarshaledResult(p1: MyCompactStruct?) -> MyCompactStruct?;
        [cs:encoded-result] opStringSeqMarshaledResult(p1: StringSeq?) -> StringSeq?;
        [cs:encoded-result] opIntDictMarshaledResult(p1: IntDict?) -> IntDict?;
    }
}
