// Copyright (c) ZeroC, Inc.

namespace IceRpc.Slice.Generators.Internal;

internal class Emitter
{
    private const string Indent = "    ";

    internal string Emit(IReadOnlyList<ServiceClass> serviceClasses, CancellationToken cancellationToken)
    {
        var generatedClasses = new List<string>();
        foreach (ServiceClass serviceClass in serviceClasses)
        {
            // stop if we're asked to.
            cancellationToken.ThrowIfCancellationRequested();

            string methodModifier =
                serviceClass.HasBaseServiceClass ? "public override" :
                serviceClass.IsSealed ? "public" : "public virtual";

            string dispatchImplementation;
            if (serviceClass.ServiceMethods.Count > 0)
            {
                dispatchImplementation = "";
                foreach (ServiceMethod serviceMethod in serviceClass.ServiceMethods)
                {
                    dispatchImplementation += GenerateDispatchCase(serviceMethod);
                }
                dispatchImplementation += $"\ndefault:";
                if (serviceClass.HasBaseServiceClass)
                {
                    dispatchImplementation += @"
    return base.DispatchAsync(request, cancellationToken);
";
                }
                else
                {
                    dispatchImplementation += @"
    return new(new IceRpc.OutgoingResponse(request, IceRpc.StatusCode.NotImplemented));
";
                }

                dispatchImplementation = @$"
switch (request.Operation)
{{
    {dispatchImplementation.WithIndent(Indent)}
}}".Trim();
            }
            else
            {
                dispatchImplementation = serviceClass.HasBaseServiceClass ?
                    "return base.DispatchAsync(request, cancellationToken);" :
                    "return new(new IceRpc.OutgoingResponse(request, IceRpc.StatusCode.NotImplemented));";
            }

            // We need to implement IDispatcher all the time, even when there is a base class. The base class may or
            // may not implement IDispatcher.

            string dispatcherClass = $@"
/// <summary>Implements <see cref=""IceRpc.IDispatcher"" /> for the Slice interface(s) implemented by this class.
/// </summary>
partial {serviceClass.Keyword} {serviceClass.Name} : IceRpc.IDispatcher
{{
    /// <summary>Dispatches an incoming request to a method of {serviceClass.Name} based on the operation name carried
    /// by the request.</summary>
    /// <param name=""request"">The incoming request.</param>
    /// <param name=""cancellationToken"">A cancellation token that receives the cancellation requests.</param>
    /// <returns>The outgoing response.</returns>
    /// <exception cref=""IceRpc.DispatchException"">Thrown if the operation name carried by the request does not
    /// correspond to any method implemented by this class. The exception status code is
    /// <see cref=""IceRpc.StatusCode.NotImplemented"" /> in this case.</exception>
    {methodModifier} global::System.Threading.Tasks.ValueTask<IceRpc.OutgoingResponse> DispatchAsync(
        IceRpc.IncomingRequest request,
        global::System.Threading.CancellationToken cancellationToken)
    {{
        {dispatchImplementation.WithIndent("        ")}
    }}
}}";

            string container = dispatcherClass;
            ContainerDefinition? containerDefinition = serviceClass;
            while (containerDefinition.Enclosing is ContainerDefinition enclosing)
            {
                container = GenerateContainer($"partial {enclosing.Keyword} {enclosing.Name}", container);
                containerDefinition = enclosing;
            }

            if (serviceClass.ContainingNamespace is not null)
            {
                container = GenerateContainer($"namespace {serviceClass.ContainingNamespace}", container);
            }
            generatedClasses.Add(container);
        }

        string generated = @$"
// <auto-generated/>
// IceRpc.Slice.Generators version: {typeof(ServiceGenerator).Assembly.GetName().Version!.ToString(3)}
#nullable enable

#pragma warning disable CS0612 // Type or member is obsolete
#pragma warning disable CS0618 // Type or member is obsolete
#pragma warning disable CS0619 // Type or member is obsolete

using IceRpc.Slice;
using ZeroC.Slice;

";
        generated += string.Join("\n\n", generatedClasses).Trim();
        generated += "\n";
        return generated.ReplaceLineEndings();
    }

    private static string GenerateContainer(string header, string body)
    {
        return $@"
{header}
{{
    {body.WithIndent(Indent)}
}}".Trim();
    }

    private string GenerateDispatchCase(ServiceMethod serviceMethod)
    {
        string codeBlock = @$"
case ""{serviceMethod.OperationName}"":";

        if (!serviceMethod.Idempotent)
        {
            codeBlock += @"
    request.CheckNonIdempotent();";
        }
        if (serviceMethod.CompressReturn)
        {
            codeBlock += @"
    request.Features = IceRpc.Features.FeatureCollectionExtensions.With(
        request.Features,
        IceRpc.Features.CompressFeature.Compress);";
        }

        string thisInterface = $"((global::{serviceMethod.FullInterfaceName})this)";

        string method;
        if (serviceMethod.ParameterCount <= 1)
        {
            method = $"{thisInterface}.{serviceMethod.DispatchMethodName}Async";
        }
        else
        {
            string splattedArgs = string.Join(", ", serviceMethod.ParameterFieldNames.Select(name => $"args.{name}"));
            method = @$"(args, features, cancellationToken) =>
            {thisInterface}.{serviceMethod.DispatchMethodName}Async({splattedArgs}, features, cancellationToken)";
        }

        codeBlock += @$"
    return request.DispatchOperationAsync(
        decodeArgs: global::{serviceMethod.FullInterfaceName}.Request.Decode{serviceMethod.DispatchMethodName}Async,
        method: {method},";

        // We don't use the generated Response.EncodeXxx method when ReturnCount is 0. So we could not generate it.
        if (serviceMethod.ReturnCount > 0)
        {
            if (serviceMethod.ReturnCount == 1)
            {
                if (serviceMethod.ReturnStream)
                {
                    codeBlock += @$"
        encodeReturnValue: (_, encodeOptions) =>
            global::{serviceMethod.FullInterfaceName}.Response.Encode{serviceMethod.DispatchMethodName}(encodeOptions),
        encodeReturnValueStream:
            global::{serviceMethod.FullInterfaceName}.Response.EncodeStreamOf{serviceMethod.DispatchMethodName},";
                }
                else if (serviceMethod.EncodedReturn)
                {
                    codeBlock += @$"
        encodeReturnValue: (returnValue, _) => returnValue,";
                }
                else
                {
                    codeBlock += @$"
        encodeReturnValue: global::{serviceMethod.FullInterfaceName}.Response.Encode{serviceMethod.DispatchMethodName},";
                }
            }
            else
            {
                // Splatting required.
                var nonStreamReturnNames = new List<string>(serviceMethod.ReturnFieldNames);
                if (serviceMethod.ReturnStream)
                {
                    nonStreamReturnNames.RemoveAt(serviceMethod.ReturnFieldNames.Length - 1);
                }

                string encodeArgs = string.Join(
                    ", ",
                    nonStreamReturnNames.Select(name => $"returnValue.{name}"));

                if (serviceMethod.EncodedReturn)
                {
                    codeBlock += @$"
        encodeReturnValue: (returnValue, _) => {encodeArgs},";
                }
                else
                {
                    codeBlock += @$"
        encodeReturnValue: (returnValue, encodeOptions) =>
            global::{serviceMethod.FullInterfaceName}.Response.Encode{serviceMethod.DispatchMethodName}({encodeArgs}, encodeOptions),";
                }

                if (serviceMethod.ReturnStream)
                {
                    string encodeStreamArg =
                        $"returnValue.{serviceMethod.ReturnFieldNames[serviceMethod.ReturnFieldNames.Length - 1]}";

                    codeBlock += @$"
        encodeReturnValueStream: (returnValue, encodeOptions) =>
            global::{serviceMethod.FullInterfaceName}.Response.EncodeStreamOf{serviceMethod.DispatchMethodName}({encodeStreamArg}, encodeOptions),";
                }
            }
        }

        if (serviceMethod.ExceptionSpecification.Length > 0)
        {
            string exceptionList =
                string.Join(" or ", serviceMethod.ExceptionSpecification.Select(ex => $"global::{ex}"));

            codeBlock += @$"
        inExceptionSpecification: sliceException => sliceException is {exceptionList},";
        }

        codeBlock += @$"
        cancellationToken: cancellationToken);";

        return codeBlock;
    }
}
